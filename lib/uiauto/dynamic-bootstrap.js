// Generate a bootstrap for the UIAuto Instruments script containing
// the environment variables we need.

import path from 'path';
import _ from 'lodash';
import crypto from 'crypto';
import { fs, mkdirp } from 'appium-support';
import buildScript from './build-script';
import logger from './logger';
import { DEFAULT_INSTRUMENTS_SOCKET } from './uiauto-client';


let BOOTSTRAP_JS_PATH = path.resolve(__dirname, '..', '..', '..', 'uiauto', 'bootstrap.js');
let COMMAND_PROXY_CLIENT_PATH = path.resolve(__dirname, 'bin', 'command-proxy-client.js');
if (!__dirname.match(/build\/lib\/uiauto$/)) {
  BOOTSTRAP_JS_PATH = path.resolve(__dirname, '..', 'uiauto', 'bootstrap.js');
  COMMAND_PROXY_CLIENT_PATH = path.resolve(__dirname, 'bin', 'command-proxy-client.js');
}

function getEnv (opts = {}) {
  // build an object with the required properties for bootstrap
  return {
    nodePath: process.execPath,
    commandProxyClientPath: COMMAND_PROXY_CLIENT_PATH,
    instrumentsSock: opts.sock || DEFAULT_INSTRUMENTS_SOCKET,
    interKeyDelay: opts.interKeyDelay || null,
    justLoopInfinitely: opts.justLoopInfinitely,
    autoAcceptAlerts: opts.autoAcceptAlerts,
    autoDismissAlerts: opts.autoDismissAlerts,
    sendKeyStrategy: opts.sendKeyStrategy,
    initialLocation: opts.initialLocation,
  };
}

async function buildCode (opts) {
  // only build the code if it hasn't been done before
  if (opts.code) return opts.code;

  let env = getEnv(opts);
  logger.debug(`Dynamic env: ${JSON.stringify(env)}`);

  let bootstrapJs = BOOTSTRAP_JS_PATH;
  // if special imports were sent in, make use of them
  let imports = (opts.imports && opts.imports.pre) ? opts.imports.pre : [];
  let bootstrapCode = await buildScript(bootstrapJs, imports);

  // generate the dynamic part of the bootstrap code
  // with the environment set up properly
  let lines = [];
  lines.push('// This file is automatically generated. Do not manually modify!');
  lines.push('');
  lines.push(bootstrapCode);
  lines.push('');
  lines.push('bootstrap({');
  // add each defined variable to the environment
  for (let [key, value] of _.toPairs(env)) {
    if (!_.isUndefined(value)) {
      let quote = _.isString(value) ? '\"' : '';
      lines.push(`  "${key}": ${quote}${value}${quote},`);
    }
  }
  // get rid of the last comma that was added
  lines[lines.length - 1] = lines[lines.length - 1].replace(/,$/, '');
  lines.push('});');
  return lines.join('\r\n');
}

function computeHash (code) {
  return crypto
    .createHash('md5')
    .update(code)
    .digest('hex')
    .substring(0, 16);
}

function getDynamicBootstrapDir (opts = {}) {
  // figuring out where to store dynamic bootstrap
  let dynamicBootstrapDir;
  if (process.env.APPIUM_BOOTSTRAP_DIR) {
    // mainly for test
    dynamicBootstrapDir = process.env.APPIUM_BOOTSTRAP_DIR;
  } else if (process.env.HOME) {
    dynamicBootstrapDir = path.resolve(process.env.HOME,
      'Library/Application Support/appium/bootstrap');
  } else {
    // no user dir, using tmp
    dynamicBootstrapDir = path.resolve(opts.tmpDir || '/tmp', 'appium/bootstrap');
  }
  return dynamicBootstrapDir;
}

async function writeDynamicBootstrapIfNecessary (dynamicBootstrapDir, dynamicBootstrapPath, code, hash) {
  await mkdirp(dynamicBootstrapDir);

  // check if there is existing code and it has the same hash
  let codeIsGood = true;
  try {
    let existingCode = await fs.readFile(dynamicBootstrapPath);
    codeIsGood = computeHash(existingCode) === hash;
  } catch (err) {
    codeIsGood = false;
  }

  // write file if the old code is not the same
  if (codeIsGood) {
    logger.debug(`Reusing dynamic bootstrap: ${dynamicBootstrapPath}`);
  } else {
    logger.debug(`Creating or overwriting dynamic bootstrap: ${dynamicBootstrapPath}`);
    await fs.writeFile(dynamicBootstrapPath, code, {flag: 'w+'});
  }
}

async function prepareBootstrap (opts = {}) {
  logger.debug('Preparing bootstrap code');

  let dynamicBootstrapDir = getDynamicBootstrapDir(opts);
  logger.debug(`Dynamic bootstrap dir: ${dynamicBootstrapDir}`);

  // building code and hash
  let code = await buildCode(opts);
  let hash = computeHash(code);
  let dynamicBootstrapPath = path.resolve(dynamicBootstrapDir, `bootstrap-${hash}.js`);
  logger.debug(`Dynamic bootstrap code: ${code.split('\n')[0]}...`);
  logger.debug(`Dynamic bootstrap path: ${dynamicBootstrapPath}`);
  await writeDynamicBootstrapIfNecessary(dynamicBootstrapDir,
    dynamicBootstrapPath, code, hash);

  return dynamicBootstrapPath;
}

export { prepareBootstrap, getEnv };
